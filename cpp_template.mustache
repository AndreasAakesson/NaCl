#include <iostream>
#include <net/inet4>
#include <net/ip4/cidr.hpp>
#include <plugins/nacl.hpp>
{{#has_nats}}
#include <net/nat/napt.hpp>
{{/has_nats}}
{{#has_gateways}}
#include <net/router.hpp>
{{/has_gateways}}
{{#has_vlans}}
#include <net/vlan>
{{/has_vlans}}

using namespace net;

{{#has_gateways}}
std::unique_ptr<Router<IP4>> nacl_router_obj;
{{/has_gateways}}
{{#enable_ct}}
std::shared_ptr<Conntrack> nacl_ct_obj;
{{/enable_ct}}
{{#has_nats}}
std::unique_ptr<nat::NAPT> nacl_natty_obj;
{{/has_nats}}
{{#has_functions}}

namespace custom_made_classes_from_nacl {

{{#filters}}
class {{title}} : public nacl::Filter {
public:
	Filter_verdict<IP4> operator()(IP4::IP_packet_ptr pckt, Inet<IP4>& stack, Conntrack::Entry_ptr ct_entry) {
		{{{content}}}
	}
};

{{/filters}}
{{#nats}}
class {{title}} : public nacl::Filter {
public:
	Filter_verdict<IP4> operator()(IP4::IP_packet_ptr pckt, Inet<IP4>& stack, Conntrack::Entry_ptr ct_entry) {
		{{{content}}}
		// At the end of a Nat we want to accept the packet that hasn't been DNATed or SNATed
		return {std::move(pckt), Filter_verdict_type::ACCEPT};
	}
};

{{/nats}}
} //< namespace custom_made_classes_from_nacl

{{/has_functions}}
void register_plugin_nacl() {
	INFO("NaCl", "Registering NaCl plugin");

	{{#ifaces}}
	{{#config_is_static}}
	auto& {{name}} = Inet4::stack<{{index}}>();
	{{name}}.network_config({{address}}, {{netmask}}{{#gateway}}, {{.}}{{/gateway}}{{^gateway}}, 0{{/gateway}}{{#dns}}, {{.}}{{/dns}});
	{{/config_is_static}}
	{{#config_is_dhcp}}
	auto& {{name}} = Inet4::stack<{{index}}>();
	Inet4::ifconfig<{{index}}>(10.0, [&{{name}}] (bool timedout) {
		if (timedout) {
			INFO("NaCl plugin interface {{name}}", "DHCP request timed out. Nothing to do.");
			return;
		}
		INFO("NaCl plugin interface {{name}}", "IP address updated: %s", {{name}}.ip_addr().str().c_str());
	});
	{{/config_is_dhcp}}
	{{#config_is_dhcp_fallback}}
	auto& {{name}} = Inet4::stack<{{index}}>();
	Inet4::ifconfig<{{index}}>(10.0, [&{{name}}] (bool timedout) {
		if (timedout) {
			INFO("NaCl plugin interface {{name}}", "DHCP timeout (%s) - falling back to static configuration", {{name}}.ifname().c_str());
			{{name}}.network_config({{address}}, {{netmask}}{{#gateway}}, {{.}}{{/gateway}}{{^gateway}}, 0{{/gateway}}{{#dns}}, {{.}}{{/dns}});
		}
	});
	{{/config_is_dhcp_fallback}}
	{{/ifaces}}
	{{#ifaces_with_vlans}}

	// For each iface:
	auto& {{iface}}_nic = {{iface}}.nic();
	auto& {{iface}}_manager = VLAN_manager::get({{iface_index}});
	// For each vlan connected to this iface:
	{{#vlans}}
	Super_stack::inet().create<IP4>({{iface}}_manager.add({{iface}}_nic, {{index}}), {{iface_index}}, {{index}}).network_config({{address}}, {{netmask}}{{#gateway}}, {{.}}{{/gateway}}{{^gateway}}, 0{{/gateway}});
	{{/vlans}}
	{{/ifaces_with_vlans}}

	{{#filters}}
	custom_made_classes_from_nacl::{{title}} {{name}};
	{{/filters}}
	{{#nats}}

	custom_made_classes_from_nacl::{{title}} {{name}};
	{{/nats}}
	{{#pushes}}

	{{^is_gateway_push}}
	{{#function_names}}
	{{name}}.ip_obj().{{chain}}_chain().chain.push_back({{function_name}});
	{{/function_names}}
	{{/is_gateway_push}}
	{{/pushes}}
	{{#has_gateways}}
	{{#gateways}}

	// Router

	INFO("NaCl", "Setup routing");
	Router<IP4>::Routing_table routing_table {
		{{#routes}}
		{ {{#net}}{{.}}{{/net}}{{#host}}{{.}}{{/host}}, {{#netmask}}{{.}}, {{/netmask}}{{#nexthop}}{{.}}{{/nexthop}}{{^nexthop}}0{{/nexthop}}{{#iface}}, {{.}}{{/iface}}{{#cost}}, {{.}}{{/cost}}{{^cost}}, 1{{/cost}} }{{#comma}},{{/comma}}
		{{/routes}}
	};
	nacl_router_obj = std::make_unique<Router<IP4>>(routing_table);
	{{#send_time_exceeded}}
	// Set send_time_exceeded:
	nacl_router_obj->send_time_exceeded = {{.}};
	{{/send_time_exceeded}}
	{{#pushes}}
	{{#is_gateway_push}}
	{{#function_names}}
	{{name}}->{{chain}}_chain.chain.push_back({{function_name}});
	{{/function_names}}
	{{/is_gateway_push}}
	{{/pushes}}
	// Set ip forwarding on every iface mentioned in routing_table
	{{#ip_forward_ifaces}}
	{{iface}}.set_forward_delg(nacl_router_obj->forward_delg());
	{{/ip_forward_ifaces}}
	{{/gateways}}
	{{/has_gateways}}
	{{#enable_ct}}

	// Ct

	nacl_ct_obj = std::make_shared<Conntrack>();
	{{#conntracks}}
	{{#limit}}nacl_ct_obj->maximum_entries = {{.}};{{/limit}}
	{{#reserve}}nacl_ct_obj->reserve({{.}});{{/reserve}}
	{{/conntracks}}
	{{#enable_ct_ifaces}}

	INFO("NaCl", "Enabling Conntrack on {{iface}}");
	{{iface}}.enable_conntrack(nacl_ct_obj);
	{{/enable_ct_ifaces}}
	{{/enable_ct}}
	{{#has_nats}}

	// NAT

	nacl_natty_obj = std::make_unique<nat::NAPT>(nacl_ct_obj);
	{{#has_masquerades}}

	auto masq = [](IP4::IP_packet_ptr pckt, Inet<IP4>& stack, Conntrack::Entry_ptr entry)->auto {
		nacl_natty_obj->masquerade(*pckt, stack, entry);
		return Filter_verdict<IP4>{std::move(pckt), Filter_verdict_type::ACCEPT};
	};
	auto demasq = [](IP4::IP_packet_ptr pckt, Inet<IP4>& stack, Conntrack::Entry_ptr entry)->auto {
		nacl_natty_obj->demasquerade(*pckt, stack, entry);
		return Filter_verdict<IP4>{std::move(pckt), Filter_verdict_type::ACCEPT};
	};
	{{#masquerades}}

	INFO("NaCl", "Enable MASQUERADE on {{iface}}");
	{{iface}}.ip_obj().prerouting_chain().chain.push_back(demasq);
	{{iface}}.ip_obj().postrouting_chain().chain.push_back(masq);
	{{/masquerades}}
	{{/has_masquerades}}
	{{#has_snats}}

	auto snat_translate = [](IP4::IP_packet_ptr pckt, Inet<IP4>&, Conntrack::Entry_ptr entry)-> auto {
		nacl_natty_obj->snat(*pckt, entry);
		return Filter_verdict<IP4>{std::move(pckt), Filter_verdict_type::ACCEPT};
	};
	{{#snats}}
	{{iface}}.ip_obj().postrouting_chain().chain.push_back(snat_translate);
	{{/snats}}
	{{/has_snats}}
	{{/has_nats}}
	{{#has_load_balancers}}

	/* Load balancers
	{{#load_balancers}}

	Name: {{name}}
	Layer: {{layer}}

	Clients iface: {{clients_iface_name}}
	Clients port: {{port}}
	Clients wait queue limit: {{wait_queue_limit}}
	Clients session limit: {{session_limit}}

	Servers iface: {{servers_iface_name}}
	Servers algorithm: {{algorithm}}
	Servers pool:
	{{#pool}}

	Node address: {{address}}
	Node port: {{port}}
	{{/pool}}
	{{/load_balancers}}
	*/
	{{/has_load_balancers}}
}