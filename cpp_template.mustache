#include <iostream>
#include <net/inet4>
#include <net/ip4/cidr.hpp>
#include <plugins/nacl.hpp>
{{#has_nats}}
#include <net/nat/napt.hpp>
{{/has_nats}}
{{#has_gateways}}
#include <net/router.hpp>
{{/has_gateways}}
{{#has_vlans}}
#include <net/vlan>
{{/has_vlans}}

using namespace net;

{{#has_gateways}}
std::unique_ptr<Router<IP4>> nacl_router_obj;
{{/has_gateways}}
{{#has_functions}}
std::shared_ptr<Conntrack> nacl_ct_obj;
{{/has_functions}}
{{#has_nats}}
std::unique_ptr<nat::NAPT> nacl_natty_obj;
{{/has_nats}}
{{#has_functions}}

namespace custom_made_classes_from_nacl {

{{#filters}}
class {{title}} : public nacl::Filter {
public:
	Filter_verdict operator()(IP4::IP_packet& pckt, Inet<IP4>& stack, Conntrack::Entry_ptr ct_entry) {
		{{{content}}}
	}
};

{{/filters}}
{{#nats}}
class {{title}} : public nacl::Filter {
public:
	Filter_verdict operator()(IP4::IP_packet& pckt, Inet<IP4>& stack, Conntrack::Entry_ptr ct_entry) {
		{{{content}}}
		// At the end of a Nat we want to accept the packet that hasn't been DNATed or SNATed
		return Filter_verdict::ACCEPT;
	}
};

{{/nats}}
} //< namespace custom_made_classes_from_nacl

{{/has_functions}}
void register_plugin_nacl() {
	INFO("NaCl", "Registering NaCl plugin");

	{{#ifaces}}
	{{#config_is_static}}
	auto& {{name}} = Inet4::stack<{{index}}>();
	{{name}}.network_config({{address}}, {{netmask}}{{#gateway}}, {{.}}{{/gateway}}{{^gateway}}, 0{{/gateway}}{{#dns}}, {{.}}{{/dns}});
	{{/config_is_static}}
	{{#config_is_dhcp}}
	auto& {{name}} = Inet4::stack<{{index}}>();
	Inet4::ifconfig<{{index}}>(10.0, [&{{name}}] (bool timedout) {
		if (timedout) {
			INFO("NaCl plugin interface {{name}}", "DHCP request timed out. Nothing to do.");
			return;
		}
		INFO("NaCl plugin interface {{name}}", "IP address updated: %s", {{name}}.ip_addr().str().c_str());
	});
	{{/config_is_dhcp}}
	{{#config_is_dhcp_fallback}}
	auto& {{name}} = Inet4::stack<{{index}}>();
	Inet4::ifconfig<{{index}}>(10.0, [&{{name}}] (bool timedout) {
		if (timedout) {
			INFO("NaCl plugin interface {{name}}", "DHCP timeout (%s) - falling back to static configuration", {{name}}.ifname().c_str());
			{{name}}.network_config({{address}}, {{netmask}}{{#gateway}}, {{.}}{{/gateway}}{{^gateway}}, 0{{/gateway}}{{#dns}}, {{.}}{{/dns}});
		}
	});
	{{/config_is_dhcp_fallback}}
	{{/ifaces}}
	{{#ifaces_with_vlans}}
	
	// For each iface:
	auto& {{iface}}_nic = {{iface}}.nic();
	auto& {{iface}}_manager = VLAN_manager::get({{iface_index}});
	// For each vlan connected to this iface:
	{{#vlans}}
	Super_stack::inet().create<IP4>({{iface}}_manager.add({{iface}}_nic, {{index}}), {{iface_index}}, {{index}}).network_config({{address}}, {{netmask}}{{#gateway}}, {{.}}{{/gateway}}{{^gateway}}, 0{{/gateway}});
	{{/vlans}}
	{{/ifaces_with_vlans}}

	{{#filters}}
	custom_made_classes_from_nacl::{{title}} {{name}};
	{{/filters}}
	{{#nats}}

	custom_made_classes_from_nacl::{{title}} {{name}};
	{{/nats}}
	{{#pushes}}

	{{#function_names}}
	{{iface}}.ip_obj().{{chain}}_chain().chain.push_back({{function_name}});
	{{/function_names}}
	{{/pushes}}
	{{#has_gateways}}

	// Router

	INFO("NaCl", "Setup routing");
	Router<IP4>::Routing_table routing_table {
		{{#gateways}}
		{{#routes}}
		{ {{#net}}{{.}}{{/net}}{{#host}}{{.}}{{/host}}, {{#netmask}}{{.}}, {{/netmask}}{{#nexthop}}{{.}}{{/nexthop}}{{^nexthop}}0{{/nexthop}}{{#iface}}, {{.}}{{/iface}}{{#cost}}, {{.}}{{/cost}}{{^cost}}, 1{{/cost}} }{{#comma}},{{/comma}}
		{{/routes}}
		{{/gateways}}
	};
	nacl_router_obj = std::make_unique<Router<IP4>>(routing_table);
	// Set ip forwarding on every iface mentioned in routing_table
	{{#ip_forward_ifaces}}
	{{iface}}.set_forward_delg(nacl_router_obj->forward_delg());
	{{/ip_forward_ifaces}}
	{{/has_gateways}}
	{{#has_functions}}

	// Ct

	nacl_ct_obj = std::make_shared<Conntrack>();

	// Enable conntrack on all ifaces created by default
	{{#ifaces}}
	INFO("NaCl", "Enable Conntrack on {{name}}");
	{{name}}.enable_conntrack(nacl_ct_obj);
	{{/ifaces}}
	{{/has_functions}}
	/* If not enable on all by default:
	{{#ct_ifaces}}
	INFO("NaCl", "Enable Conntrack on {{iface}}");
	{{iface}}.enable_conntrack(nacl_ct_obj);
	{{/ct_ifaces}}
	*/
	{{#has_nats}}

	// NAT

	nacl_natty_obj = std::make_unique<nat::NAPT>(nacl_ct_obj);
	{{#has_masquerades}}

	auto masq = [](IP4::IP_packet& pckt, Inet<IP4>& stack, Conntrack::Entry_ptr entry)->auto {
		nacl_natty_obj->masquerade(pckt, stack, entry);
		return Filter_verdict::ACCEPT;
	};
	auto demasq = [](IP4::IP_packet& pckt, Inet<IP4>& stack, Conntrack::Entry_ptr entry)->auto {
		nacl_natty_obj->demasquerade(pckt, stack, entry);
		return Filter_verdict::ACCEPT;
	};
	{{#masquerades}}

	INFO("NaCl", "Enable MASQUERADE on {{iface}}");
	{{iface}}.ip_obj().prerouting_chain().chain.push_back(demasq);
	{{iface}}.ip_obj().postrouting_chain().chain.push_back(masq);
	{{/masquerades}}
	{{/has_masquerades}}
	{{#has_snats}}

	auto snat_translate = [](IP4::IP_packet& pckt, Inet<IP4>&, Conntrack::Entry_ptr entry)-> auto {
		nacl_natty_obj->snat(pckt, entry);
		return Filter_verdict::ACCEPT;
	};
	{{#snats}}
	{{iface}}.ip_obj().postrouting_chain().chain.push_back(snat_translate);
	{{/snats}}
	{{/has_snats}}
	{{/has_nats}}
}